<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Background Remover</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f4f4f4;
      padding: 20px;
    }
    .dropzone {
      border: 2px dashed #aaa;
      padding: 30px;
      background: white;
      margin-bottom: 20px;
      cursor: pointer;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
    }
    .controls {
      margin: 20px 0;
    }
    input[type="color"] {
      margin-left: 10px;
    }
    #downloadBtn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>AI Background Remover</h2>
  <div class="dropzone" id="dropzone">Drag & Drop Image or Click to Upload</div>
  <input type="file" id="fileInput" accept="image/*" style="display:none">
  <div class="controls">
    Background Fill Color:
    <input type="color" id="bgColor" value="#ffffff">
    <button id="removeBtn">Remove Background</button>
    <button id="downloadBtn">Download PNG</button>
  </div>
  <canvas id="canvas"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const removeBtn = document.getElementById('removeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const bgColorInput = document.getElementById('bgColor');
    let imageBitmap = null;

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.background = '#eef'; });
    dropzone.addEventListener('dragleave', () => dropzone.style.background = 'white');
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.style.background = 'white';
      handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    async function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) return;
      const img = await createImageBitmap(file);
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      imageBitmap = img;
    }

    async function removeBackground() {
      if (!imageBitmap) return alert('Please upload an image first.');

      
      const modelURL = 'https://github.com/danielgatis/rembg/releases/download/v0.0.0/u2netp.onnx';
      const session = await ort.InferenceSession.create(modelURL);

      const width = imageBitmap.width;
      const height = imageBitmap.height;
      const offCanvas = new OffscreenCanvas(width, height);
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(imageBitmap, 0, 0);
      const imgData = offCtx.getImageData(0, 0, width, height);

      const inputTensor = preprocess(imgData);
      const feeds = { input: inputTensor };
      const results = await session.run(feeds);
      const output = results[Object.keys(results)[0]].data;

      const mask = new Float32Array(output);
      const bgColor = hexToRGB(bgColorInput.value);
      const outImage = ctx.createImageData(width, height);

      for (let i = 0; i < width * height; i++) {
        const alpha = Math.min(255, Math.max(0, mask[i] * 255));
        for (let c = 0; c < 3; c++) {
          outImage.data[i * 4 + c] = imageBitmap.data ? imageBitmap.data[i * 4 + c] : bgColor[c];
        }
        outImage.data[i * 4 + 3] = alpha;
      }

      ctx.putImageData(outImage, 0, 0);
    }

    function preprocess(imgData) {
      const [width, height] = [imgData.width, imgData.height];
      const input = new Float32Array(3 * width * height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let c = 0; c < 3; c++) {
            const val = imgData.data[(y * width + x) * 4 + c] / 255.0;
            input[c * width * height + y * width + x] = val;
          }
        }
      }
      return new ort.Tensor('float32', input, [1, 3, height, width]);
    }

    function hexToRGB(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }

    removeBtn.onclick = removeBackground;
    downloadBtn.onclick = () => {
      const link = document.createElement('a');
      link.download = 'bg_removed.png';
      link.href = canvas.toDataURL();
      link.click();
    };
  </script>
</body>
</html>