<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Background Remover</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f4f4f4;
      padding: 20px;
    }
    .dropzone {
      border: 2px dashed #aaa;
      padding: 30px;
      background: white;
      margin-bottom: 20px;
      cursor: pointer;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
    }
    .controls {
      margin: 20px 0;
    }
    input[type="color"], select {
      margin-left: 10px;
      padding: 5px;
    }
    #downloadBtn, #removeBtn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      margin-left: 10px;
    }
    #progress {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
  </style>
</head>
<body>
  <h2>AI Background Remover</h2>
  <div class="dropzone" id="dropzone">Drag & Drop Image or Click to Upload</div>
  <input type="file" id="fileInput" accept="image/*" style="display:none">
  <div class="controls">
    Background Fill Color:
    <input type="color" id="bgColor" value="#ffffff">
    <label for="modelSelect">Model:</label>
    <select id="modelSelect">
      <option value="u2netp">Fast (u2netp - Low Accuracy)</option>
      <option value="u2net">High Quality (u2net - Best Accuracy)</option>
    </select>
    <button id="removeBtn">Remove Background</button>
    <button id="downloadBtn">Download PNG</button>
    <div id="progress"></div>
  </div>
  <canvas id="canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const removeBtn = document.getElementById('removeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const bgColorInput = document.getElementById('bgColor');
    const modelSelect = document.getElementById('modelSelect');
    const progress = document.getElementById('progress');

    let imageBitmap = null;

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.background = '#eef'; });
    dropzone.addEventListener('dragleave', () => dropzone.style.background = 'white');
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.style.background = 'white';
      handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    async function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) return;
      const img = await createImageBitmap(file);
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      imageBitmap = img;
    }

    async function removeBackground() {
      if (!imageBitmap) return alert('Please upload an image first.');

      const selectedModel = modelSelect.value;
      //const modelURL = selectedModel === 'u2net'
      //  ? 'https://huggingface.co/frankminors123/U2Net_ONNX/resolve/main/u2net.onnx'
     //   : 'https://john699-ui.github.io/background_remover/u2netp.onnx';
      const modelURL = 'https://john699-ui.github.io/background_remover/u2netp.onnx';

      progress.textContent = 'Loading model...';
      const session = await ort.InferenceSession.create(modelURL);

      progress.textContent = 'Processing image...';

      const width = imageBitmap.width;
      const height = imageBitmap.height;

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 320;
      tempCanvas.height = 320;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(imageBitmap, 0, 0, 320, 320);
      const resizedData = tempCtx.getImageData(0, 0, 320, 320);

      const inputTensor = preprocess(resizedData);
      const feeds = { 'input.1': inputTensor };
      const results = await session.run(feeds);
      const output = results[Object.keys(results)[0]].data;

      const mask = new Float32Array(output);
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = 320;
      maskCanvas.height = 320;
      const maskCtx = maskCanvas.getContext('2d');
      const maskImageData = maskCtx.createImageData(320, 320);

      for (let i = 0; i < 320 * 320; i++) {
        const a = Math.min(255, Math.max(0, mask[i] * 255));
        maskImageData.data[i * 4 + 3] = a;
        maskImageData.data[i * 4 + 0] = 255;
        maskImageData.data[i * 4 + 1] = 255;
        maskImageData.data[i * 4 + 2] = 255;
      }
      maskCtx.putImageData(maskImageData, 0, 0);

      const finalMaskCanvas = document.createElement('canvas');
      finalMaskCanvas.width = width;
      finalMaskCanvas.height = height;
      const finalMaskCtx = finalMaskCanvas.getContext('2d');
      finalMaskCtx.drawImage(maskCanvas, 0, 0, width, height);
      const finalMaskData = finalMaskCtx.getImageData(0, 0, width, height);

      const offCanvas = document.createElement('canvas');
      offCanvas.width = width;
      offCanvas.height = height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(imageBitmap, 0, 0);
      const imgData = offCtx.getImageData(0, 0, width, height);
      const bgColor = hexToRGB(bgColorInput.value);
      const outImage = ctx.createImageData(width, height);

      for (let i = 0; i < width * height; i++) {
        const alpha = finalMaskData.data[i * 4 + 3];
        for (let c = 0; c < 3; c++) {
          outImage.data[i * 4 + c] = alpha > 128 ? imgData.data[i * 4 + c] : bgColor[c];
        }
        outImage.data[i * 4 + 3] = alpha;
      }

      ctx.putImageData(outImage, 0, 0);
      progress.textContent = 'Done!';
    }

    function preprocess(imgData) {
      const [targetW, targetH] = [320, 320];
      const input = new Float32Array(3 * targetW * targetH);
      for (let y = 0; y < targetH; y++) {
        for (let x = 0; x < targetW; x++) {
          for (let c = 0; c < 3; c++) {
            const val = imgData.data[(y * targetW + x) * 4 + c] / 255.0;
            input[c * targetW * targetH + y * targetW + x] = val;
          }
        }
      }
      return new ort.Tensor('float32', input, [1, 3, targetH, targetW]);
    }

    function hexToRGB(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }

    removeBtn.onclick = removeBackground;
    downloadBtn.onclick = () => {
      const link = document.createElement('a');
      link.download = 'bg_removed.png';
      link.href = canvas.toDataURL();
      link.click();
    };
  </script>
</body>
</html>
