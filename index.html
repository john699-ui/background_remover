<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Background Remover</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f4f4f4;
      padding: 20px;
    }
    .dropzone {
      border: 2px dashed #aaa;
      padding: 30px;
      background: white;
      margin-bottom: 20px;
      cursor: pointer;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
      touch-action: none;
    }
    .controls {
      margin: 20px 0;
    }
    input[type="color"], select {
      margin-left: 10px;
      padding: 5px;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    #progress {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
  </style>
</head>
<body>
  <h2>AI Background Remover</h2>
  <div class="dropzone" id="dropzone">Drag & Drop Image or Click to Upload</div>
  <input type="file" id="fileInput" accept="image/*" style="display:none">

  <div class="controls">
    Background Fill Color: <input type="color" id="bgColor" value="#ffffff">
    <label for="modelSelect">Model:</label>
    <select id="modelSelect">
      <option value="u2netp">Fast (u2netp)</option>
      <option value="u2net">High Quality (u2net)</option>
    </select>
    <button id="removeBtn">Remove Background</button>
    <button id="downloadBtn">Download PNG</button>
    <div id="progress"></div>
  </div>

  <div class="controls" id="polygonControls">
    <button id="undoPointBtn">Undo Last Point</button>
    <button id="applyEraseBtn">Apply Erase Mask</button>
  </div>

  <canvas id="canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const removeBtn = document.getElementById('removeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const bgColorInput = document.getElementById('bgColor');
    const modelSelect = document.getElementById('modelSelect');
    const progress = document.getElementById('progress');
    const undoPointBtn = document.getElementById('undoPointBtn');
    const applyEraseBtn = document.getElementById('applyEraseBtn');
    const polygonControls = document.getElementById('polygonControls');

    let imageBitmap = null;
    let polygonPoints = [];
    let drawingPolygon = false;
    let session = null;

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.background = '#eef'; });
    dropzone.addEventListener('dragleave', () => dropzone.style.background = 'white');
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.style.background = 'white';
      handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    canvas.addEventListener('pointerdown', e => {
      if (!drawingPolygon) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      polygonPoints.push({ x, y });
      drawPolygon();
    });

    undoPointBtn.onclick = () => {
      polygonPoints.pop();
      drawPolygon();
    };

    applyEraseBtn.onclick = () => {
      if (polygonPoints.length < 3) return;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');

      maskCtx.fillStyle = '#000';
      maskCtx.beginPath();
      maskCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
      for (let i = 1; i < polygonPoints.length; i++) {
        maskCtx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
      }
      maskCtx.closePath();
      maskCtx.fill();

      const maskData = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const bgColor = hexToRGB(bgColorInput.value);

      for (let i = 0; i < imgData.data.length; i += 4) {
        if (maskData.data[i] > 0) {
          imgData.data[i] = bgColor[0];
          imgData.data[i + 1] = bgColor[1];
          imgData.data[i + 2] = bgColor[2];
          imgData.data[i + 3] = 255;
        }
      }

      ctx.putImageData(imgData, 0, 0);
      polygonPoints = [];
      drawPolygon();
    };

    removeBtn.onclick = async () => {
      if (!imageBitmap) return;
      const modelURL = modelSelect.value === 'u2net'
        ? 'https://your-host/u2net.onnx'
        : 'https://your-host/u2netp.onnx';

      progress.textContent = 'Loading model...';
      session = await ort.InferenceSession.create(modelURL);
      progress.textContent = 'Running model...';

      // NOTE: actual preprocessing and postprocessing logic not included here
      // This is a placeholder to indicate inference runs

      setTimeout(() => {
        progress.textContent = 'Background removed (simulated)';
      }, 1000);
    };

    downloadBtn.onclick = () => {
      const link = document.createElement('a');
      link.download = 'bg_removed.png';
      link.href = canvas.toDataURL();
      link.click();
    };

    function drawPolygon() {
      if (!imageBitmap) return;
      ctx.drawImage(imageBitmap, 0, 0);
      if (polygonPoints.length === 0) return;
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
      for (let i = 1; i < polygonPoints.length; i++) {
        ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
      }
      ctx.stroke();
    }

    function hexToRGB(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }

    async function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) return;
      const img = await createImageBitmap(file);
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      imageBitmap = img;
      drawingPolygon = true;
      polygonControls.style.display = 'block';
    }
  </script>
</body>
</html>


